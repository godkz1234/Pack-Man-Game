#include <stdio.h>
#include <windows.h>
#include <conio.h>
#include <stdlib.h>
#include <time.h>

#define WIDTH 31
#define HEIGHT 31
#define ITEM_COUNT 10  // 생성할 아이템 개수

#define UP 72
#define LEFT 75
#define RIGHT 77
#define DOWN 80

typedef struct Character {
    int x;
    int y;
    const char* shape;
} Character;

typedef struct Item {
    int x;
    int y;
    int active;
} Item;

char maze[HEIGHT][WIDTH] = {
{ '1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1' },
{ '1','0','0','0','0','0','0','0','0','0','0','0','0','0','0','1','0','0','0','0','0','0','0','0','0','0','0','0','0','0','1' },
{ '1','0','1','1','1','1','0','1','1','1','1','0','1','1','0','1','0','1','1','0','1','1','1','1','0','1','1','1','1','0','1' },
{ '1','0','1','1','1','1','0','1','1','1','1','0','1','1','0','1','0','1','1','0','1','1','1','1','0','1','1','1','1','0','1' },
{ '1','0','1','1','1','1','0','1','1','1','1','0','1','1','0','1','0','1','1','0','1','1','1','1','0','1','1','1','1','0','1' },
{ '1','0','1','1','1','1','0','1','1','1','1','0','1','1','0','1','0','1','1','0','1','1','1','1','0','1','1','1','1','0','1' },
{ '1','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','1' },
{ '1','0','1','1','1','1','0','1','1','0','1','1','1','1','1','1','1','1','1','1','1','0','1','1','0','1','1','1','1','0','1' },
{ '1','0','1','1','1','1','0','1','1','0','1','1','1','1','1','1','1','1','1','1','1','0','1','1','0','1','1','1','1','0','1' },
{ '1','0','0','0','0','0','0','1','1','0','0','0','0','1','1','1','1','1','0','0','0','0','1','1','0','0','0','0','0','0','1' },
{ '1','1','1','1','1','1','0','1','1','1','1','1','0','1','1','1','1','1','0','1','1','1','1','1','0','1','1','1','1','1','1' },
{ '1','1','1','1','1','1','0','1','1','1','1','1','0','1','1','1','1','1','0','1','1','1','1','1','0','1','1','1','1','1','1' },
{ '1','1','1','1','1','1','0','1','1','0','0','0','0','1','1','1','1','1','0','0','0','0','1','1','0','1','1','1','1','1','1' },
{ '1','1','1','1','1','1','0','1','1','0','1','1','0','0','0','0','0','0','0','1','1','0','1','1','0','1','1','1','1','1','1' },
{ '1','0','0','0','0','0','0','0','0','0','0','0','0','1','1','1','1','1','0','0','0','0','0','0','0','0','0','0','0','0','1' },
{ '1','0','1','1','1','1','0','1','1','1','0','1','0','0','0','0','0','0','0','1','0','1','1','1','0','1','1','1','1','0','1' },
{ '1','0','0','0','0','1','0','1','1','1','0','1','1','1','1','1','1','1','1','1','0','1','1','1','0','1','0','0','0','0','1' },
{ '1','0','0','0','0','1','0','1','1','1','0','0','0','0','0','0','0','0','0','0','0','1','1','1','0','1','0','0','0','0','1' },
{ '1','0','1','1','1','1','0','1','1','1','0','1','1','1','1','1','1','1','1','1','0','1','1','1','0','1','1','1','1','0','1' },
{ '1','0','0','0','0','0','0','0','0','0','0','1','0','0','0','1','0','0','0','1','0','0','0','0','0','0','0','0','0','0','1' },
{ '1','0','1','1','1','1','0','1','1','1','0','0','0','0','0','1','0','0','0','0','0','1','1','1','0','1','1','1','1','0','1' },
{ '1','0','0','0','0','1','0','0','0','0','0','0','0','0','0','1','0','0','0','0','0','0','0','0','0','1','0','0','0','0','1' },
{ '1','1','1','1','0','1','0','0','1','1','0','1','0','0','0','1','0','0','0','1','0','1','1','0','0','1','0','1','1','1','1' },
{ '1','1','1','1','0','1','0','0','1','1','0','1','1','1','1','1','1','1','1','1','0','1','1','0','0','1','0','1','1','1','1' },
{ '1','1','1','1','0','1','0','0','1','1','0','0','0','0','0','0','0','0','0','0','0','1','1','0','0','1','0','1','1','1','1' },
{ '1','0','0','0','0','0','0','0','1','1','0','1','1','1','1','1','1','1','1','1','0','1','1','0','0','0','0','0','0','0','1' },
{ '1','0','1','1','1','1','1','1','1','1','0','1','0','0','0','1','0','0','0','1','0','1','1','1','1','1','1','1','1','0','1' },
{ '1','0','1','1','1','1','1','1','1','1','0','1','0','0','0','1','0','0','0','1','0','1','1','1','1','1','1','1','1','0','1' },
{ '1','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','1' },
{ '1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1' }
};

// Position 함수 선언
void Position(int x, int y);

void Render(Character player, Character ghosts[], int ghostCount, Item items[], int score) {
    system("cls");  

    for (int i = 0; i < HEIGHT; i++) {
        for (int j = 0; j < WIDTH; j++) {
            if (maze[i][j] == '0') {
                printf("  ");
            }
            else if (maze[i][j] == '1') {
                printf("■");
            }
        }
        printf("\n");
    }

    // 플레이어 위치에 플레이어 그리기
    Position(player.x, player.y);
    printf("%s", player.shape);

    // 고스트 위치에 고스트들 그리기
    for (int i = 0; i < ghostCount; i++) {
        Position(ghosts[i].x, ghosts[i].y);
        printf("%s", ghosts[i].shape);
    }

    // 활성화된 아이템 그리기
    for (int i = 0; i < ITEM_COUNT; i++) {
        if (items[i].active) {
            Position(items[i].x, items[i].y);
            printf("★");
        }
    }

    // 점수 표시
    Position(0, HEIGHT + 1);
    printf("Score: %d\n", score);
}

void Position(int x, int y) {
    COORD position = { x * 2, y };  // x를 2배로 하여 공백 고려
    SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), position);
}

void MoveGhost(Character* ghost, Character player, int* moveCounter) {
    (*moveCounter)++;
    if (*moveCounter % 3 != 0) {
        return;  // 3번 루프 중 1번만 이동, 고스트의 속도 조절
    }

    if (ghost->x < player.x) {
        if (maze[ghost->y][ghost->x + 1] != '1') {
            ghost->x++;
        }
    }
    else if (ghost->x > player.x) {
        if (maze[ghost->y][ghost->x - 1] != '1') {
            ghost->x--;
        }
    }

    if (ghost->y < player.y) {
        if (maze[ghost->y + 1][ghost->x] != '1') {
            ghost->y++;
        }
    }
    else if (ghost->y > player.y) {
        if (maze[ghost->y - 1][ghost->x] != '1') {
            ghost->y--;
        }
    }
}

void GenerateItems(Item items[]) {
    srand(time(NULL));  // 랜덤 시드 설정

    int generated = 0;
    while (generated < ITEM_COUNT) {
        int x = rand() % WIDTH;
        int y = rand() % HEIGHT;

        if (maze[y][x] == '0') {  // 빈 공간에만 아이템을 생성
            items[generated].x = x;
            items[generated].y = y;
            items[generated].active = 1;
            generated++;
        }
    }
}

int CheckItemCollection(Character* player, Item items[]) {
    for (int i = 0; i < ITEM_COUNT; i++) {
        if (items[i].active && player->x == items[i].x && player->y == items[i].y) {
            items[i].active = 0;  // 아이템 비활성화
            return 1;  // 점수 1점 추가
        }
    }
    return 0;
}

int AllItemsCollected(Item items[]) {
    for (int i = 0; i < ITEM_COUNT; i++) {
        if (items[i].active) {
            return 0;  // 아직 남은 아이템이 있다면 0을 반환
        }
    }
    return 1;  // 모든 아이템이 수집되었다면 1을 반환
}

void GameOver() {
    Position(0, HEIGHT + 2);
    printf("Game Over! 고스트에게 붙잡혔습니다!\n");
}

void Victory() {
    Position(0, HEIGHT + 2);
    printf("Victory! 맵 안에 있는 모든 아이템을 다먹었습니다.!\n");
}

// 새로운 함수: 시작 화면 출력
void ShowStartScreen() {
    system("cls");
    printf("###################################\n");
    printf("#                                 #\n");
    printf("#          Pac-Man                #\n");
    printf("#                                 #\n");
    printf("#   모든 아이템을 먹으면 승리!   #\n");
    printf("#    고스트에게서 도망치세요!     #\n");
    printf("#                                 #\n");
    printf("#         -조작방법-              #\n");
    printf("#           4방향키               #\n");
    printf("#                                 #\n");
    printf("#   -Press any key to start-      #\n");
    printf("#                                 #\n");
    printf("###################################\n");

    _getch();  // 사용자가 아무 키나 누르면 계속 진행
}

// 게임 종료 후 다시 시작 여부를 묻는 함수
int AskRestart() {
    printf("게임이 종료되었습니다. 다시 시작하려면 r키를 누르세요.\n");
    char key = _getch();  // 사용자가 키 입력을 기다림
    if (key == 'r' || key == 'R') {
        return 1;  // 다시 시작
    }
    return 0;  // 종료
}

int main() {
    while (1) {
        // 시작 화면 호출
        ShowStartScreen();

        Character player = { 1, 1, "▲" };  // 초기 위치 (1, 1)
        Character ghosts[3] = {            // 고스트 3마리 정의
            { 20, 17, "●" },               // 고스트 1 초기 위치
            { 22, 15, "●" },               // 고스트 2 초기 위치
            { 18, 19, "●" }                // 고스트 3 초기 위치
        };
        Item items[ITEM_COUNT];  // 아이템 배열
        int score = 0;
        int moveCounters[3] = { 0, 0, 0 };  // 각 고스트의 이동을 제어하는 변수
        int playerMoved = 0;  // 플레이어가 처음 움직였는지 확인하는 변수

        GenerateItems(items);  // 아이템 생성

        char key = 0;

        while (1) {
            Render(player, ghosts, 3, items, score);

            if (_kbhit()) {
                key = _getch();

                if (key == -32) {
                    key = _getch();
                }

                switch (key) {
                case UP:
                    if (maze[player.y - 1][player.x] != '1') player.y--;
                    break;
                case LEFT:
                    if (maze[player.y][player.x - 1] != '1') player.x--;
                    break;
                case RIGHT:
                    if (maze[player.y][player.x + 1] != '1') player.x++;
                    break;
                case DOWN:
                    if (maze[player.y + 1][player.x] != '1') player.y++;
                    break;
                }

                playerMoved = 1;  // 플레이어가 움직였음을 표시
            }

            if (playerMoved) {
                // 각 고스트가 플레이어를 추격하게 함
                for (int i = 0; i < 3; i++) {
                    MoveGhost(&ghosts[i], player, &moveCounters[i]);  // 각 고스트별로 moveCounter를 전달
                }
            }

            // 아이템 수집 체크
            score += CheckItemCollection(&player, items);

            // 승리 조건 체크
            if (AllItemsCollected(items)) {
                Victory();  // 승리 함수 호출
                break;
            }

            // 각 고스트와 충돌 체크
            for (int i = 0; i < 3; i++) {
                if (player.x == ghosts[i].x && player.y == ghosts[i].y) {
                    GameOver();  // 게임 오버 함수 호출
                    return 0;
                }
            }

            Sleep(100);  // 프레임 속도 조절
        }

        // 게임이 끝나면 다시 시작 여부를 물어봄
        if (!AskRestart()) {
            break;  // 다시 시작하지 않으면 게임 종료
        }
    }

    return 0;
}
